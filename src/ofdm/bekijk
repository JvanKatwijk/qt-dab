
mMeanLevelVector wordt geinitialiseerd
mMeamPowerVector wordt geinitialiseerd


	for (int i = 
	const cmplx fftBin = mFftBuffer [fftBin];
	const float fftBinPhase = std::arg (fftBin);
	const float fftBinAbsPhase =
	               turn_phase_to_first_quadrant(fftBinPhase);
	const float fftBinAbsLevel = std::abs(fftBin);
	const float fftBinPower	= fftBinAbsLevel * fftBinAbsLevel;
//
//	we hebben nu de phase and amp gewoon en abs
//
	float & meanLevelPerBinRef = mMeanLevelVector [nomCarrIdx];
	float & meanPowerPerBinRef = mMeanPowerVector[nomCarrIdx];

	float & meanPowerPerBinRef = mMeanPowerVector [nomCarrIdx];
	mean_filter (meanLevelPerBinRef, fftBinAbsLevel, ALPHA);
	mean_filter (meanPowerPerBinRef, fftBinPower,    ALPHA);

	mean_filter(mMeanPowerOvrAll, fftBinPower, ALPHA / (float)mDabPar.K);


//	Collect data for "Log Likelihood Ratio"
	const float meanLevelAtAxisPerBin = meanLevelPerBinRef * M_SQRT1_2f;
// x-distance to reference point
	const float realLevelDistPerBin =
	                     std::abs(real(fftBin) - meanLevelAtAxisPerBin);
// y-distance to reference point
	const float imagLevelDistPerBin =
	                     std::abs( imag (fftBin)) - meanLevelAtAxisPerBin);

	float llrBitReal =
	                -mLlrScaling * 2 * meanLevelPerBinRef /
	                                 meanSigmaSqPerBinRef * real (fftBin);
	float llrBitImag =
	                -mLlrScaling * 2 * meanLevelPerBinRef /
	                                 meanSigmaSqPerBinRef * imag (fftBin);
	limit_symmetrically (llrBitReal, F_VITERBI_SOFT_BIT_VALUE_MAX);
	limit_symmetrically (llrBitImag, F_VITERBI_SOFT_BIT_VALUE_MAX);
	const float weightRrl =
	          std::min(std::abs (llrBitReal), std::abs (llrBitImag));
	mean_filter (mMeanModQual, weightRrl, ALPHA / (float)mDabPar.K);

	


